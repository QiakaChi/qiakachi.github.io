<!DOCTYPE html>
<html data-color-mode="light" data-dark-theme="dark" data-light-theme="light" lang="zh-CN">
<head>
    <meta content="text/html; charset=utf-8" http-equiv="content-type" />
    <meta name="viewport" content="width=device-width,initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <link href='https://mirrors.sustech.edu.cn/cdnjs/ajax/libs/Primer/21.0.7/primer.css' rel='stylesheet' />
    <style>body[data-ui-pending] #content {opacity:0;transition:opacity 0.3s ease;}</style><script>document.documentElement.setAttribute('data-ui-pending','true');</script><link rel='stylesheet' href='assets/GmeekBaseTheme.css'><script src='assets/GmeekCustomizeCss.js' defer></script><script src='https://blog.meekdai.com/Gmeek/plugins/GmeekTOC.js'></script><script src='https://blog.meekdai.com/Gmeek/plugins/lightbox.js'></script>
    <link rel="icon" href="https://avatars.githubusercontent.com/u/98450248?v=4"><script>
        let theme = localStorage.getItem("meek_theme") || "light";
        document.documentElement.setAttribute("data-color-mode", theme);
    </script>
<meta name="description" content="官方仓库：[https://github.com/OS-Agent-Survey/OS-Agent-Survey](https://github.com/OS-Agent-Survey/OS-Agent-Survey)

# 一、引言
![](https://cdn.nlark.com/yuque/0/2025/png/39039688/1755233964985-2b15b6c1-e0bb-47b2-91b8-0d6f156611f2.png)

<details class='lake-collapse'><summary id='ucf0062fb'><span class='ne-text'>章节目录</span></summary><p id='u727c908c' class='ne-p'><span class='ne-text'>第二章	讨论 OS Agents 的基础知识。">
<meta property="og:title" content="[论文笔记] OS Agents-A Survey on MLLM-based Agents for General Computing Devices Use">
<meta property="og:description" content="官方仓库：[https://github.com/OS-Agent-Survey/OS-Agent-Survey](https://github.com/OS-Agent-Survey/OS-Agent-Survey)

# 一、引言
![](https://cdn.nlark.com/yuque/0/2025/png/39039688/1755233964985-2b15b6c1-e0bb-47b2-91b8-0d6f156611f2.png)

<details class='lake-collapse'><summary id='ucf0062fb'><span class='ne-text'>章节目录</span></summary><p id='u727c908c' class='ne-p'><span class='ne-text'>第二章	讨论 OS Agents 的基础知识。">
<meta property="og:type" content="article">
<meta property="og:url" content="https://qiakachi.github.io/post/%5B-lun-wen-bi-ji-%5D%20OS%20Agents-A%20Survey%20on%20MLLM-based%20Agents%20for%20General%20Computing%20Devices%20Use.html">
<meta property="og:image" content="https://avatars.githubusercontent.com/u/98450248?v=4">
<title>[论文笔记] OS Agents-A Survey on MLLM-based Agents for General Computing Devices Use</title>



</head>
<style>
body{box-sizing: border-box;min-width: 200px;max-width: 900px;margin: 20px auto;padding: 45px;font-size: 16px;font-family: sans-serif;line-height: 1.25;}
#header{display:flex;padding-bottom:8px;border-bottom: 1px solid var(--borderColor-muted, var(--color-border-muted));margin-bottom: 16px;}
#footer {margin-top:64px; text-align: center;font-size: small;}

</style>

<style>
.postTitle{margin: auto 0;font-size:40px;font-weight:bold;}
.title-right{display:flex;margin:auto 0 0 auto;}
.title-right .circle{padding: 14px 16px;margin-right:8px;}
#postBody{border-bottom: 1px solid var(--color-border-default);padding-bottom:36px;}
#postBody hr{height:2px;}
#cmButton{height:48px;margin-top:48px;}
#comments{margin-top:64px;}
.g-emoji{font-size:24px;}
@media (max-width: 600px) {
    body {padding: 8px;}
    .postTitle{font-size:24px;}
}
.copy-feedback {
    display: none;
    position: absolute;
    top: 10px;
    right: 50px;
    color: var(--color-fg-on-emphasis);
    background-color: var(--color-fg-muted);
    border-radius: 3px;
    padding: 5px 8px;
    font-size: 12px;
}
</style>




<body>
    <div id="header">
<h1 class="postTitle">[论文笔记] OS Agents-A Survey on MLLM-based Agents for General Computing Devices Use</h1>
<div class="title-right">
    <a href="https://qiakachi.github.io" id="buttonHome" class="btn btn-invisible circle" title="首页">
        <svg class="octicon" width="16" height="16">
            <path id="pathHome" fill-rule="evenodd"></path>
        </svg>
    </a>
    
    <a href="https://github.com/QiakaChi/qiakachi.github.io/issues/4" target="_blank" class="btn btn-invisible circle" title="Issue">
        <svg class="octicon" width="16" height="16">
            <path id="pathIssue" fill-rule="evenodd"></path>
        </svg>
    </a>
    

    <a class="btn btn-invisible circle" onclick="modeSwitch();" title="切换主题">
        <svg class="octicon" width="16" height="16" >
            <path id="themeSwitch" fill-rule="evenodd"></path>
        </svg>
    </a>

</div>
</div>
    <div id="content">
<div class="markdown-body" id="postBody"><p>官方仓库：<a href="https://github.com/OS-Agent-Survey/OS-Agent-Survey">https://github.com/OS-Agent-Survey/OS-Agent-Survey</a></p>
<h1>一、引言</h1>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/3d72ac1ff977b505a745c00bc4a67a3e03582af1094225b165344a5f78997e08/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032352f706e672f33393033393638382f313735353233333936343938352d32623135623663312d653062622d343762322d393162382d3064366631353636313166322e706e67"><img src="https://camo.githubusercontent.com/3d72ac1ff977b505a745c00bc4a67a3e03582af1094225b165344a5f78997e08/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032352f706e672f33393033393638382f313735353233333936343938352d32623135623663312d653062622d343762322d393162382d3064366631353636313166322e706e67" alt="" data-canonical-src="https://cdn.nlark.com/yuque/0/2025/png/39039688/1755233964985-2b15b6c1-e0bb-47b2-91b8-0d6f156611f2.png" style="max-width: 100%;"></a></p>
<details><summary id="user-content-ucf0062fb"><span>章节目录</span></summary><p id="user-content-u727c908c"><span>第二章	讨论 OS Agents 的基础知识。</span></p><p id="user-content-u96924aa4"><span>第三章	探讨构建 OS Agents 的两个关键方面：开发特定领域的基础模型，以及围绕这些模型构建有效的代理框架。</span></p><p id="user-content-u67eb8b47"><span>第四章	回顾常用的评估协议和基准测试，用于评估操作系统代理的性能。</span></p><p id="user-content-u6686f68f"><span>第五章	讨论 OS Agents 面临的挑战和未来方向，特别关注与安全和隐私相关的问题，以及个性化和自我进化。</span></p></details>
<h1>二、OS Agent 基础知识</h1>
<p>OS Agents 具备三种核心能力：理解（understanding），规划（planning）和对齐（grounding）。</p>
<p>grounding 是指将<strong>自然语言文本与视觉场景</strong>之间进行对齐或连接的任务。在这个任务中，文本描述和视觉信息需要建立联系，以实现跨模态的理解和交互。</p>
<h2>（一）关键组件</h2>
<ol>
<li>环境（Enviroment）【详见 4.2 节】</li>
</ol>
<p>指其运行的系统或平台，包括桌面端、移动端或网页端。</p>
<ol start="2">
<li>观测空间（Observation Space）【详见 3.2.1 节】</li>
</ol>
<p>涵盖了 OS Agent 可以访问的有关系统状态和用户活动的信息；</p>
<p>这些观测信息指导 Agent 理解环境，做出明智的决策，并确定实现用户定义目标的适当行动；</p>
<p>观测包括捕获来自操作系统的输出（如进行特定处理的屏幕图像）或文本数据（如屏幕描述和基于 Web 的上下文中 HTML 代码）；</p>
<p>将这些不同数据结构整合在一起的多模态输入给 Agent 带来了有效理解和执行任务的重大挑战。</p>
<ol start="3">
<li>行动空间（Action Space）【详见 3.2.4 节】</li>
</ol>
<p>定义了 OS Agent 通过 OS 提供的输入界面与环境交互的一系列操作；</p>
<p>可分为 input 操作（代表了与数字界面交互的主要方式）、navigation 操作（用于在系统界面中进行移动）和 extended 操作（利用外部工具或服务）。</p>
<h2>（二）能力</h2>
<ol>
<li>理解（Understanding）</li>
</ol>
<p>指 OS Agents 对复杂操作系统环境的理解能力；</p>
<p>环境包含多种多样的数据格式，如 HTML 代码和截图中捕获的 GUI；</p>
<p>随着代码长度增加、信息稀疏、高分辨率界面充斥着微小图标、细小文字和密集排列的元素时，这种复杂性会进一步加剧；</p>
<p>这样的环境对代理的<strong>感知能力</strong>提出了挑战，并要求其具备先进的<strong>上下文理解能力</strong>；</p>
<p>理解能力不仅对于旨在实现信息检索的任务至关重要，也是有效执行广泛其他任务的基本前提条件。</p>
<ol start="2">
<li>规划（Planning）</li>
</ol>
<p>指使 OS Agents 能够将复杂任务分解为可管理的子任务、并制定一系列行动以实现特定目标的能力；</p>
<p>在操作系统中进行规划时，代理通常需要根据环境反馈和历史行为动态调整计划；</p>
<p>在动态且不可预测的场景中，还需要采用诸如 ReAct 和CoAT 等推理策略确保任务的有效执行。</p>
<ol start="3">
<li>对齐（Grounding）</li>
</ol>
<p>指将文本指令或计划转化为在运行环境中可执行动作的能力；</p>
<p>代理必须识别屏幕上的元素并提供必要的参数，以确保成功执行；</p>
<p>尽管操作系统环境通常包含大量可选择的元素和可能的操作，但由此产生的复杂性使得接地任务尤为具有挑战性。</p>
<h1>三、关键方面</h1>
<p>讨论构建 OS Agents 的有效策略。</p>
<h2>（一）基础模型</h2>
<p>包括两个关键组成：<strong>模型架构</strong>和<strong>训练策略</strong>。前者定义了模型如何在 OS 环境中处理输入和输出，后者增强了模型完成复杂任务的能力，主要包括预训练、监督微调和强化学习。</p>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/859a3faf48d8568d4ad5a3c3c7035ef1a8174103638b34a833e372da54b84aa9/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032352f706e672f33393033393638382f313735353233353431353136382d32393963663638392d383465312d343832302d616631322d3334393265653339363034312e706e67"><img src="https://camo.githubusercontent.com/859a3faf48d8568d4ad5a3c3c7035ef1a8174103638b34a833e372da54b84aa9/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032352f706e672f33393033393638382f313735353233353431353136382d32393963663638392d383465312d343832302d616631322d3334393265653339363034312e706e67" alt="OS Agents 的基础模型主要包括的内容：架构和训练策略（预训练、监督微调和强化学习）。" data-canonical-src="https://cdn.nlark.com/yuque/0/2025/png/39039688/1755235415168-299cf689-84e1-4820-af12-3492ee396041.png" style="max-width: 100%;"></a></p>
<h3>1、架构</h3>
<p>通常做法是利用现有的开源 LLM 和 MLLM 来构建模型；一些架构可以通过将 LLM 与视觉编码器（Vision Encoder）连接起来实现，使模型能够同时处理文本和视觉信息；此外，MLLM 也经常通过加入补充模块进行调整，以满足特定需求，例如高分辨率图像理解。</p>
<ol>
<li>现有的 LLMs</li>
</ol>
<p>现有 LLMs 架构已经能够处理用户指令并读取HTML代码，以感知用户界面中包含的信息；</p>
<p>因此，一些研究直接选择开源的 LLMs 作为骨干模型而未进一步优化其架构，以开发用于操作系统代理的基础模型；</p>
<p>T5 和LLaMA 是比较流行的架构。</p>
<ol start="2">
<li>现有的 MLLMs</li>
</ol>
<p>MLLMs 额外具备处理视觉信息能力，且同时保留复杂自然语言处理能力；</p>
<p>LLaVA、Qwen-VL、InternVL、CogVLM等架构可以有效地开发 OS Agents 的基础模型。</p>
<ol start="3">
<li>串联的 MLLMs</li>
</ol>
<p>选择适合处理 OS 任务的 LLM 和视觉编码器，并以类似于现有 MLLM 的方式进行串联。</p>
<ol start="4">
<li>修改后的 MLLMs</li>
</ol>
<p>为了增强基础模型的理解能力，进一步调整 MLLM 的架构。</p>
<h3>2、预训练（Pre-training）</h3>
<p>大多数现有的预训练方法都利用了从具备强大文本或视觉理解能力的通用预训练模型中进行持续的预训练，利用了这些预训练模型中已有的知识，提升模型在 GUI 相关任务上的表现，促进视觉信息与文本信息之间内在关联的获取。</p>
<ol>
<li>数据来源</li>
</ol>
<p>（1）公开可用数据</p>
<p>仅依靠公开可用数据进行预训练不足以应对 OS Agent 所需的复杂且多样的任务。</p>
<p>（2）合成数据</p>
<p>在预训练过程中引入合成数据。</p>
<ol start="2">
<li>任务</li>
</ol>
<p>（1）屏幕对齐（Screen grounding）</p>
<p>预训练使模型能够根据文本描述从图像中提取目标元素的二维坐标或边界框。</p>
<p>（2）屏幕理解（Screen understanding）</p>
<p>一些研究认为，用于 OS Agent 的基础模型应能够从图像中提取语义信息，并分析和解释整个图像内容。</p>
<p>（3）光学字符识别（OCR）</p>
<p>OCR 在处理包含文本内容的GUI元素方面起着至关重要的作用。</p>
<h3>3、有监督微调（Supervised Finetuning）</h3>
<p>SFT 用以增强 OS Agents 的 planning 和 grounding 能力，需要付出努力收集特定领域的数据，以弥合自然图像任务与GUI任务之间的领域差距。</p>
<ol>
<li>planning</li>
</ol>
<p>收集多步轨迹，为这些轨迹合成指令。</p>
<ol start="2">
<li>grounding</li>
</ol>
<p>首先将对象上的操作与 GUI 图像连接起来，然后合成参考这些图像的指令，常见的连接方法是渲染 GUI 的源代码；</p>
<p>与单纯学习操作源代码相比，通过其视觉形式进行操作的学习能够展现出更优异的性能，因为小部件之间的交互更加直观；</p>
<p>同时，通过GUI图像进行学习有助于避免幻觉现象，对未见过的GUI具有泛化能力。</p>
<h3>4、强化学习（RL）</h3>
<p>强化学习中，Agent 通过与环境的交互来学习最优决策。</p>
<p>早期利用 RL 训练 Agent 在网页和移动应用上完成任务，大模型通常用作特征提取器。</p>
<p>最近研究已逐渐转向“LLM as Agents”的范式，即让LLMs充当策略模型，并通过强化学习来使大型模型与最终目标保持一致。</p>
<details><summary id="user-content-u3e95021f"><span>【AI翻译】LLM as Agents 范式的具体文献</span></summary><p id="user-content-u508509fb"><span>Thil等人[2024]利用Miniwob++基准测试，通过微调基于T5的模型并结合</span><span>分层规划</span><span>，同时整合多模态神经网络，采用监督学习和强化学习相结合的方式，改进了LLMs中的网页导航性能。Fereidouni等人[2024]采用Flan-T5架构，并引入了通过强化学习进行训练的方法。他们首先通过行为克隆利用人类演示数据，然后进一步使用PPO对智能体进行训练。Liu等人[2024a]遵循将LLMs作为智能体的范式，提出了AutoGLM，这是一种用于通过图形用户界面（GUI）自主控制计算设备的基础智能体。他们设计了一个中间接口，能够</span><span>有效地分离规划行为和接地行为</span><span>，并开发了一种自进化在线课程强化学习方法，以实现鲁棒的错误恢复和性能提升。FengPeiyuan等人[2024]提出了一种基于LLMs的智能体新型强化学习框架AGILE，该框架集成了LLMs、记忆模块、工具模块和执行器模块。强化学习使LLMs能够预测动作，而执行器模块则负责管理这些动作，从而增强决策能力和交互能力。此外，强化学习也被引入到仅基于视觉的模型[Shaw et al., 2023]和多模态大语言模型（MLLMs）[Bai et al., 2024, Wang et al., 2024a]的智能体中。</span></p></details>
<h2>（二）Agent 框架</h2>
<p>OS Agents 通常由四个核心组件组成：感知、规划、记忆和行动。</p>
<h3>1、感知（Perception）</h3>
<p>感知是 OS Agents 收集和分析其环境信息的过程。感知组件需要观察当前环境并提取相关信息以协助 Agent 的规划、行动和记忆优化。感知可以根据输入模态大致分操作系统的文本描述和 GUI 截图。</p>
<ol>
<li>操作系统的文本描述（Textual Description of OS）</li>
</ol>
<p>早期的研究受到限制，因为 LLMs 只能处理文本输入；</p>
<p>它们主要依赖工具将操作系统状态转换为结构化的文本描述，例如HTML、DOM或可访问性树；</p>
<p>这些方法可能会生成不相关或冗余的信息，对 OS Agents 对环境的判断产生负面影响，并导致错误操作；</p>
<p>一些新的方法被提出用于过滤掉无效的描述，确保 OS Agents 仅观察相关信息。</p>
<ol start="2">
<li>GUI 截图</li>
</ol>
<p>MLLMs 能够处理视觉输入，目前越来越多研究将 GUI 截图视为 OS Agents 的感知输入；</p>
<p>现有的大多数视觉编码器都是在通用数据上进行预训练的，使得 OS Agents 对 GUI 元素的敏感性较低；</p>
<p>为了增强在不微调视觉编码器的情况下理解 GUI 截图的能力，现有研究主要集中在GUI grounding。</p>
<h3>2、规划（Planning）</h3>
<p>规划是根据当前环境制定一系列行动以实现特定目标的过程，使 OS Agents 能够将复杂任务分解为更小、更易于管理的子任务，并逐步解决。</p>
<p>根据规划是否固定或是否响应环境变化而迭代，将现有研究分为全局规划和迭代规划。</p>
<ol>
<li>全局（Global）</li>
</ol>
<p>OS Agents 仅生成一次全局计划，并在执行过程中不根据环境变化进行调整。Chain-of-Thought（CoT）提示 LLMs 将复杂任务分解为推理步骤，这构成了大多数 OS Agents 中全局规划的基础；</p>
<p>由于全局规划是一次性的特性，研究重点在于适应 OS Agents 的环境和任务，从一开始就提出足够可行的计划。</p>
<ol start="2">
<li>迭代（Interactive）</li>
</ol>
<p>允许 OS Agents 根据历史行为或环境变化持续迭代其计划，从而适应不断变化的环境，对有效应对动态且不可预测的环境至关重要；</p>
<p>ReAc 在 CoT 基础上，将推理与行动结果相结合，使规划更能适应环境变化，已被广泛应用于 OS Agents 的迭代式规划中。</p>
<h3>3、记忆（Memory）</h3>
<p>在增强 OS Agents 的智能性和执行效率这一研究中，记忆模块是核心组件之一。</p>
<ol>
<li>记忆来源（Memory Sources）</li>
</ol>
<p>近年研究越来越关注提高记忆的适应性和多样性，以满足更复杂任务的需求；</p>
<p>可分为内部记忆（即时信息存储）、外部记忆（外部知识支持）和特定记忆（操作优化）；</p>
<pre class="notranslate"><code class="notranslate">- 内部记忆（Internal Memory）
</code></pre>
<p>按照用途分为：</p>
<p>（1）操作历史记录</p>
<p>通过记录每一步操作，有助于 OS Agents 追踪任务路径并优化决策。</p>
<p>（2）屏幕截图</p>
<p>存储屏幕截图支持视觉推理和GUI组件识别。</p>
<p>（3）状态数据</p>
<p>存储如页面位置和窗口状态等等来自环境的动态信息，以帮助于 OS Agents 快速定位任务目标，并在不断变化的环境中保持较高的任务执行精度。</p>
<p>按照存储方式分为：</p>
<p>（1）短期记忆存储（Short-term Memory）</p>
<p>存储有关当前任务的即时信息，包括 Agent 的动作历史、状态信息以及任务的执行轨迹；</p>
<p>支持决策优化和任务追踪，为正在进行的任务提供情境支持。</p>
<p>（2）长期记忆存储（Long-term Memory）</p>
<p>存储历史任务和交互记录。</p>
<ul>
<li>外部记忆（External Memory）</li>
</ul>
<p>提供长期的知识支持，主要通过知识库、外部文档和在线信息来丰富 Agent 的记忆能力。</p>
<ul>
<li>特定记忆</li>
</ul>
<p>存储与特定任务和用户需求直接相关的信息，如任务执行规则、子任务分解方法和领域知识；</p>
<p>可存储在内部或通过外部数据源扩展；</p>
<p>还可用于记录用户档案、偏好和交互历史，以支持个性化推荐、需求预测以及隐含信息的推断。</p>
<ol start="2">
<li>记忆优化（Memory Optimization）</li>
</ol>
<p>内存优化能够在复杂任务中提升 Agent 在操作和决策方面的效率。</p>
<p>（1）管理（Management）</p>
<p>OS Agent 的记忆也可以得到有效管理，以生成更高层次的信息、整合冗余，并移除不相关或过时的信息；</p>
<p>有效的内存管理能够提升整体性能，防止因信息过载而导致的效率损失。</p>
<p>（2）成长经验（Growth Experience）</p>
<p>通过重新审视任务的每个步骤，Agent 可以分析成功与失败的原因，识别改进机会，并避免在类似场景中重复犯错。</p>
<p>（3）经验检索（Experience Retrieval）</p>
<p>OS Agent 可以通过从长期记忆中检索与当前任务相似的经验，从而高效地规划和执行操作，有助于减少冗余操作。</p>
<h3>4、行动（Action）</h3>
<p>行动空间定义了基于 (M)LLM 的 Agent 与 OS 交互的界面，涵盖计算机、移动设备和网页浏览器等平台。将 OS Agents 的动作空间分为输入操作、导航操作和扩展操作。</p>
<ol>
<li>输入操作（Input Operations）</li>
</ol>
<p>包括通过鼠标/触摸和键盘进行的交互，是 OS Agents 与数字界面交互的基础；</p>
<p>鼠标和触摸操作包括三种主要类型：点击/轻触操作、长按/按住操作和拖动/移动操作；</p>
<p>键盘操作包括基本文本输入功能和特殊按键操作（如快捷键、功能键）。</p>
<ol start="2">
<li>导航操作（Navigation Operations）</li>
</ol>
<p>使 OS Agent 能够遍历目标平台并获取足够的信息以执行后续操作，包括基本导航和特定于网页的导航功能；</p>
<p>基本导航包括：滚动操作、后退/前进导航和主页功能；</p>
<p>网络导航包括：选项卡管理和 URL 导航功能。</p>
<ol start="3">
<li>扩展操作（Extended Operations）</li>
</ol>
<p>提供了超越标准界面交互的额外功能；</p>
<p>主要包括：代码执行能力和 API 集成功能。</p>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/3c8ba8cd823604b3867c4435224c54c657a0821f6dc94f07f01dee0a258483f9/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032352f706e672f33393033393638382f313735353236343332373033382d36323136316634662d643537382d343431312d623432622d3432333031366363373365642e706e67"><img src="https://camo.githubusercontent.com/3c8ba8cd823604b3867c4435224c54c657a0821f6dc94f07f01dee0a258483f9/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032352f706e672f33393033393638382f313735353236343332373033382d36323136316634662d643537382d343431312d623432622d3432333031366363373365642e706e67" alt="表2：面向操作系统代理的近期智能体框架。TD：文本描述，GS：GUI截图，VG：视觉 grounding，SG：语义 grounding，DG：双重 grounding，GL：全局，IT：迭代，AE：自动探索，EA：经验增强，MA：管理，IO：输入操作，NO：导航操作，EO：扩展操作。" data-canonical-src="https://cdn.nlark.com/yuque/0/2025/png/39039688/1755264327038-62161f4f-d578-4411-b42b-423016cc73ed.png" style="max-width: 100%;"></a></p>
<h1>四、OS Agent 的评估（Evaluation of OS Agents）</h1>
<h2>（一）评估协议（Evaluation Protocol）</h2>
<p>对 OS Agents 进行评估的核心包括<strong>评估原则</strong>（如何开展评估过程？）和<strong>评估指标</strong>（需要评估哪些方面？）。</p>
<h3>1、评估原则（Evaluation Principle）</h3>
<p>评估过程主要分为<strong>客观评估</strong>和<strong>主观评估</strong>。</p>
<ol>
<li>客观评估（Objective Evaluation）</li>
</ol>
<p>主要基于标准化的数值指标来衡量操作 OS Agents 的性能；</p>
<p>指标通常是基于规则的计算或在标准基准数据集上进行硬编码的评估；</p>
<p>特别关注代理在感知方面的准确性、生成内容的质量、行动的有效性以及运行效率；</p>
<p>通常，特定指标的计算包括精确匹配、模糊匹配以及文本、元素和图像的语义匹配；</p>
<ol start="2">
<li>主观评估（Subjective Evaluation）</li>
</ol>
<p>旨在衡量输出结果与人类期望的匹配程度，通常应用于需要高水平理解且难以用传统指标量化的场景；</p>
<p>此类主观评价基于不同的主观方面，包括相关性、连贯性、自然性、无害性和整体质量等；</p>
<p>早期的主观评价主要依赖于直接的人类评估，虽然能获得高质量的结果，但成本高昂且难以重复；</p>
<p>后来引入 LLM，利用其强大的指令遵循能力作为评估者来替代人类判断；</p>
<p>以 LLM 为裁判的评估方法能够提供详细的注释解释，从而更细致地了解智能体的优势和劣势；</p>
<p>提高了效率，但在可靠性和可控性方面仍存在局限性。</p>
<h3>2、评估指标（Evaluation Metric）</h3>
<p>在评估过程中，给定任务指令和当前环境输入后，代理需要执行一系列连续的动作，直到任务完成。通过收集代理在这一过程中的观察结果、动作输出以及其他环境信息，可以计算出特定的指标。</p>
<p>评估范围包括细致的<strong>步骤级评估</strong>（流程中的每一步是否与预定义路径一致）和更全面的<strong>任务级评估</strong>（Agent最终是否达成目标）。</p>
<ol>
<li>步骤级评估（Step-level Evaluation）</li>
</ol>
<p>侧重于对规划轨迹进行详细、逐步的分析，对智能体在每一步所采取的动作进行精细评估；</p>
<p>直接评估智能体针对每一步指令的输出，重点关注动作的<strong>语义合理性</strong>（即动作的语义基础）以及<strong>动作的目标的匹配情况</strong>，前者通常将每一步预测的动作与参考动作直接比较，以获得操作准确率和F1值，后者根据动作类型和元素的不同，采用不同的方法得到元素准确率和F1值；</p>
<p>视觉语义理解的具体任务中存在专门的指标；</p>
<p>通过对单个步骤的所有相关指标进行汇总，可以评估该步骤的成功程度，进而获得步骤成功率；</p>
<p>尽管能够提供精细的理解，但在评估长而连续的动作序列时仍存在局限性，并且给定的任务可能有多种有效的路径，为了提高评估的鲁棒性，通常需要将最终的任务结果纳入评估之中。</p>
<ol start="2">
<li>任务级评估（Task-level Evaluation）</li>
</ol>
<p>侧重于最终输出，并评估智能体是否达到了期望的最终状态；</p>
<p>主要标准包括<strong>任务完成情况</strong>和<strong>资源利用率</strong>，前者评估智能体是否已按照指令成功完成所分配的任务，后者则考察智能体在完成任务过程中的整体效率；</p>
<ul>
<li>任务完成度指标</li>
</ul>
<p>用于衡量操作系统代理成功完成分配任务的有效性；</p>
<p>包括：总体成功率（一种直接衡量任务完成比例的方法）、准确性（评估智能体响应或动作的精确性，确保输出结果与预期结果高度一致）和奖励函数（为强化学习中的智能体分配数值，以引导其朝着特定目标前进）。</p>
<ul>
<li>效率指标</li>
</ul>
<p>用于评估智能体完成分配任务的效率；</p>
<p>考虑的因素包括步骤成本、硬件开销和时间消耗：步数比（将智能体执行的步骤数量与最优步骤数量进行比较）、API费用（用于评估与API调用相关的财务成本）、执行时间（衡量智能体完成任务所需的时间）和峰值内存占用（显示计算过程中GPU内存的最大使用量）；</p>
<p>这些效率指标对于评估智能体的实时性能至关重要，尤其是在资源受限的环境中。</p>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/f698269bd2a88fc9b26d2d89471136af58dda5ac6a71213612c9e66f09115789/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032352f706e672f33393033393638382f313735353136323030303631322d31656266383635372d363964312d343763612d396638322d3163333032366533633163612e706e67"><img src="https://camo.githubusercontent.com/f698269bd2a88fc9b26d2d89471136af58dda5ac6a71213612c9e66f09115789/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032352f706e672f33393033393638382f313735353136323030303631322d31656266383635372d363964312d343763612d396638322d3163333032366533633163612e706e67" alt="表3：OS Agents 的近期基准测试。根据平台将基准测试分为三个部分，并按发布日期排序。以下是对缩写的说明：BS：基准测试设置，M/P：移动设备，PC：桌面设备，IT：交互式，ST：静态，OET：运行环境类型，RW：真实世界，SM：模拟，GG：GUI基础，IF：信息处理，AT：代理式，CG：代码生成。" data-canonical-src="https://cdn.nlark.com/yuque/0/2025/png/39039688/1755162000612-1ebf8657-69d1-47ca-9f82-1c3026e3c1ca.png" style="max-width: 100%;"></a></p>
<h2>（二）评估基准平台（Evaluation Benchmark）</h2>
<p>平台作为一个集成的评估环境，专门涵盖了执行基准测试的虚拟设置。不同的平台会带来独特的挑战和评估重点。一些基准测试还会同时结合多个平台。</p>
<h3>1、按评估平台（Evaluation Platform）分类</h3>
<ol>
<li>移动端（Mobile）</li>
</ol>
<p>由于屏幕较小，移动 GUI elements 较为简单；</p>
<p>但 elements 需要更复杂的操作，例如精确的手势来导航小部件或进行缩放。</p>
<p>Android 的开放特性提供了更广泛的操作空间，包括标准的 GUI 交互和函数调用 API（如发送短信），这给代理的规划和动作定位能力提出了更高的要求；</p>
<p>如：Android Control 等。</p>
<ol start="2">
<li>桌面（Desktop）</li>
</ol>
<p>由于操作系统和应用程序的多样性，桌面平台更加复杂；</p>
<p>高效的桌面基准测试需要处理现实计算环境中广泛而复杂的多样性，这些环境跨越不同的操作系统、界面和应用程序；</p>
<p>因此，可管理任务的范围和测试代理的可扩展性往往受到限制；</p>
<p>如：OS World 等。</p>
<ol start="3">
<li>网页（Web）</li>
</ol>
<p>网页开放，并且使用HTML、CSS和JavaScript构建，这使得它们易于实时检查和修改；</p>
<p>由于 Agent 与网页界面的交互方式与人类相同，因此可以以低成本从任何拥有网页浏览器、键盘和鼠标的用户那里众包获取人类执行网页任务的示范数据；</p>
<p>这种易用性也引起了该领域研究人员的广泛关注；</p>
<p>如：Web shop 等。</p>
<h3>2、按基准设置（Benchmark Setting）分类</h3>
<p>OS Agents 感知和采取行动的环境空间在不同的评估基准中也有所不同，主要分为静态和交互两类，其中交互环境又进一步细分为模拟环境和真实世界环境。</p>
<ol>
<li>静态环境（static）</li>
</ol>
<p>在早期研究中较为常见，通常是通过缓存网站副本或静态数据来创建的，从而为评估建立离线上下文；</p>
<p>设置静态环境的过程相当简单，只需缓存真实网站的内容即可；</p>
<p>评估通常依赖于缓存的静态内容来进行视觉定位等任务，且仅支持一步操作；</p>
<p>然而，由于缺乏动态交互和环境反馈，此类静态评估往往不够真实和灵活，难以进行全面的评估；</p>
<p>如 Mind2Web 等。</p>
<ol start="2">
<li>交互式环境（interactive）</li>
</ol>
<p>更真实的场景，特点是动态性和交互性；</p>
<p>OS Agent 在这里可以执行一系列动作，接收来自环境的反馈，并做出相应的调整，这与静态环境不同；</p>
<p>交互式评估设置有助于在更复杂的环境中评估代理的能力，这些交互式环境可以细分为两类：</p>
<p>（1）模拟环境（simulated environment）</p>
<p>如通过创建虚拟网站，以避免由真实世界环境动态特性引起的可重复性问题，或开发了虚拟应用程序来评估OS Agent的能力；</p>
<p>目前的模拟环境通常过于简单，排除了意外情况，因此无法捕捉真实世界场景的复杂性；</p>
<p>如 FormWoB。</p>
<p>（2）真实世界环境（real-world environment）</p>
<p>具有真实性，包含真实的网站和应用程序，必须考虑到环境的持续更新、不可控的用户行为以及多样化的设备配置；</p>
<p>凸显了 Agent 需要在真实世界条件下表现出强大的泛化能力；</p>
<p>如 OSWorld，AndroidWorld 等。</p>
<h3>3、任务</h3>
<p>一系列专业化的任务已被整合到已建立的基准测试中，涵盖了从系统级任务（如安装和卸载应用程序）到日常应用（如发送电子邮件和在线购物）等各个方面。这些任务旨在衡量当前 Agent 在多大程度上能够模仿人类的表现。</p>
<ol>
<li>GUI Grounding</li>
</ol>
<p>旨在评估智能体将指令转换为各种可操作元素的能力；</p>
<p>如 PIXELHELP 提供了一个基准测试，将英文指令与用户在 mobile 模拟器上执行的操作相匹配。</p>
<ol start="2">
<li>信息处理（Information Processing）</li>
</ol>
<p>在交互式智能体的背景下，这种能力在动态且多样的环境中尤为重要，是解决复杂任务的关键组成部分；</p>
<p>包括：从各种来源检索相关数据，总结和提炼信息以满足特定用户需求；</p>
<p>在动态多样的环境中，智能体必须处理大量信息并提供准确的结果；</p>
<p>信息处理任务可以进一步分为两类：</p>
<p>（1）信息检索任务</p>
<p>通过理解指令和 GUI 界面提取所需信息或数据，考察智能体处理复杂和动态信息的能力；</p>
<p>浏览器拥有庞大的信息资源库，因此是执行信息检索任务的理想平台；</p>
<p>集成数据服务的应用程序也可作为检索平台；</p>
<p>（2）信息摘要任务</p>
<p>旨在从图形用户界面中总结指定信息，测试智能体理解并处理信息的能力；</p>
<p>如 WebLinx 中的某些任务专注于总结基于网络的新闻文章或用户评论。</p>
<ol start="3">
<li>代理任务（Agent Tasks）。</li>
</ol>
<p>代理任务旨在评估智能体的核心能力，是当前研究中的一个关键焦点；</p>
<p>在这些任务中，OS Agent 会收到指令或目标，并被要求识别所需步骤、规划行动并执行，直到达到目标状态，而无需依赖任何明确的导航指导；</p>
<p>如 WebLINX 提供了低级和高级指令，挑战智能体完成单步或多步任务，从而测试其规划能力；MMInA 强调多跳任务，要求智能体跨多个网站导航以完成给定指令。</p>
<h1>五、挑战和未来方向</h1>
<h2>（一）安全与隐私</h2>
<h3>1、攻击</h3>
<p>主要是对抗性攻击和特定环境下的安全问题。</p>
<h3>2、防御</h3>
<p>弥合这一差距需要开发强大的防御机制，以应对 OS Agents 的漏洞，例如注入攻击、后门利用以及其他潜在威胁。</p>
<h3>3、基准</h3>
<p>已引入一些安全基准测试以评估 OS Agents 在各种场景下的鲁棒性。如在线基准测试 ST-WebAgentBench 和 MobileSafetyBench的基准测试平台。</p>
<h2>（二）个性化与自我进化</h2>
<p>早期工作允许基于 LLM 的 Agent 与游戏环境交互，将体验总结为文本，从而积累记忆并促进自我进化。后来研究人员将这些原则应用于 OS Agents 领域，验证了记忆机制在 OS Agents 中的可行性。尽管由于学术界资源有限以及难以获取真实用户数据，当前的许多研究主要集中在提高特定任务的性能上，而非个性化方面，但记忆机制仍然显示出 OS Agents 随着时间推移积累用户数据的潜力，从而改善用户体验和性能。</p>
<p>此外，将记忆的模式从文本扩展到其他形式（如图像、语音）带来了显著的挑战。如何有效地管理和检索这些记忆仍然是一个尚未解决的问题。</p>
<h1>六、相关工作</h1>
<p>略</p>
<h1>七、结论</h1>
<p>（多模态）大型语言模型的发展为 OS Agents 创造了新的机遇，使先进人工智能助手的概念更接近实现。在本综述中，我们旨在概述 OS Agents 的基础知识，包括其关键组件和功能。此外，我们还回顾了构建 OS Agents 的各种方法，特别关注特定领域的基础模型和代理框架。通过讨论的评估协议和基准测试，我们探索了在各种任务中评估操作系统代理性能的方法。展望未来，我们确定了一些关键挑战，例如安全性与隐私、个性化与自我进化等，这些领域需要持续的研究和关注。本文总结了该领域的当前状态，并提出了未来工作的潜在方向，旨在推动 OS Agents 的不断发展，并支持其在学术界和工业界的适用性和实用性。</p></div>
<div style="font-size:small;margin-top:8px;float:right;"></div>

<button class="btn btn-block" type="button" onclick="openComments()" id="cmButton">评论</button>
<div class="comments" id="comments"></div>

</div>
    <div id="footer"><div id="footer1">Copyright © <span id="copyrightYear"></span> <a href="https://qiakachi.github.io">QiakaChi's Note</a></div>
<div id="footer2">
    <span id="runday"></span><span>Powered by <a href="https://meekdai.com/Gmeek.html" target="_blank">Gmeek</a></span>
</div>

<script>
var now=new Date();
document.getElementById("copyrightYear").innerHTML=now.getFullYear();

if(""!=""){
    var startSite=new Date("");
    var diff=now.getTime()-startSite.getTime();
    var diffDay=Math.floor(diff/(1000*60*60*24));
    document.getElementById("runday").innerHTML="网站运行"+diffDay+"天"+" • ";
}
</script></div>
</body>
<script>
var IconList={'sun': 'M8 10.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5zM8 12a4 4 0 100-8 4 4 0 000 8zM8 0a.75.75 0 01.75.75v1.5a.75.75 0 01-1.5 0V.75A.75.75 0 018 0zm0 13a.75.75 0 01.75.75v1.5a.75.75 0 01-1.5 0v-1.5A.75.75 0 018 13zM2.343 2.343a.75.75 0 011.061 0l1.06 1.061a.75.75 0 01-1.06 1.06l-1.06-1.06a.75.75 0 010-1.06zm9.193 9.193a.75.75 0 011.06 0l1.061 1.06a.75.75 0 01-1.06 1.061l-1.061-1.06a.75.75 0 010-1.061zM16 8a.75.75 0 01-.75.75h-1.5a.75.75 0 010-1.5h1.5A.75.75 0 0116 8zM3 8a.75.75 0 01-.75.75H.75a.75.75 0 010-1.5h1.5A.75.75 0 013 8zm10.657-5.657a.75.75 0 010 1.061l-1.061 1.06a.75.75 0 11-1.06-1.06l1.06-1.06a.75.75 0 011.06 0zm-9.193 9.193a.75.75 0 010 1.06l-1.06 1.061a.75.75 0 11-1.061-1.06l1.06-1.061a.75.75 0 011.061 0z', 'moon': 'M9.598 1.591a.75.75 0 01.785-.175 7 7 0 11-8.967 8.967.75.75 0 01.961-.96 5.5 5.5 0 007.046-7.046.75.75 0 01.175-.786zm1.616 1.945a7 7 0 01-7.678 7.678 5.5 5.5 0 107.678-7.678z', 'sync': 'M1.705 8.005a.75.75 0 0 1 .834.656 5.5 5.5 0 0 0 9.592 2.97l-1.204-1.204a.25.25 0 0 1 .177-.427h3.646a.25.25 0 0 1 .25.25v3.646a.25.25 0 0 1-.427.177l-1.38-1.38A7.002 7.002 0 0 1 1.05 8.84a.75.75 0 0 1 .656-.834ZM8 2.5a5.487 5.487 0 0 0-4.131 1.869l1.204 1.204A.25.25 0 0 1 4.896 6H1.25A.25.25 0 0 1 1 5.75V2.104a.25.25 0 0 1 .427-.177l1.38 1.38A7.002 7.002 0 0 1 14.95 7.16a.75.75 0 0 1-1.49.178A5.5 5.5 0 0 0 8 2.5Z', 'home': 'M6.906.664a1.749 1.749 0 0 1 2.187 0l5.25 4.2c.415.332.657.835.657 1.367v7.019A1.75 1.75 0 0 1 13.25 15h-3.5a.75.75 0 0 1-.75-.75V9H7v5.25a.75.75 0 0 1-.75.75h-3.5A1.75 1.75 0 0 1 1 13.25V6.23c0-.531.242-1.034.657-1.366l5.25-4.2Zm1.25 1.171a.25.25 0 0 0-.312 0l-5.25 4.2a.25.25 0 0 0-.094.196v7.019c0 .138.112.25.25.25H5.5V8.25a.75.75 0 0 1 .75-.75h3.5a.75.75 0 0 1 .75.75v5.25h2.75a.25.25 0 0 0 .25-.25V6.23a.25.25 0 0 0-.094-.195Z', 'github': 'M8 0c4.42 0 8 3.58 8 8a8.013 8.013 0 0 1-5.45 7.59c-.4.08-.55-.17-.55-.38 0-.27.01-1.13.01-2.2 0-.75-.25-1.23-.54-1.48 1.78-.2 3.65-.88 3.65-3.95 0-.88-.31-1.59-.82-2.15.08-.2.36-1.02-.08-2.12 0 0-.67-.22-2.2.82-.64-.18-1.32-.27-2-.27-.68 0-1.36.09-2 .27-1.53-1.03-2.2-.82-2.2-.82-.44 1.1-.16 1.92-.08 2.12-.51.56-.82 1.28-.82 2.15 0 3.06 1.86 3.75 3.64 3.95-.23.2-.44.55-.51 1.07-.46.21-1.61.55-2.33-.66-.15-.24-.6-.83-1.23-.82-.67.01-.27.38.01.53.34.19.73.9.82 1.13.16.45.68 1.31 2.69.94 0 .67.01 1.3.01 1.49 0 .21-.15.45-.55.38A7.995 7.995 0 0 1 0 8c0-4.42 3.58-8 8-8Z', 'copy': 'M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 0 1 0 1.5h-1.5a.25.25 0 0 0-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 0 0 .25-.25v-1.5a.75.75 0 0 1 1.5 0v1.5A1.75 1.75 0 0 1 9.25 16h-7.5A1.75 1.75 0 0 1 0 14.25Z M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0 1 14.25 11h-7.5A1.75 1.75 0 0 1 5 9.25Zm1.75-.25a.25.25 0 0 0-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 0 0 .25-.25v-7.5a.25.25 0 0 0-.25-.25Z', 'check': 'M13.78 4.22a.75.75 0 0 1 0 1.06l-7.25 7.25a.75.75 0 0 1-1.06 0L2.22 9.28a.751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018L6 10.94l6.72-6.72a.75.75 0 0 1 1.06 0Z'};
var utterancesLoad=0;

let themeSettings={
    "dark": ["dark","moon","#00f0ff","dark-blue"],
    "light": ["light","sun","#ff5000","github-light"],
    "auto": ["auto","sync","","preferred-color-scheme"]
};
function changeTheme(mode, icon, color, utheme){
    document.documentElement.setAttribute("data-color-mode",mode);
    document.getElementById("themeSwitch").setAttribute("d",value=IconList[icon]);
    document.getElementById("themeSwitch").parentNode.style.color=color;
    if(utterancesLoad==1){utterancesTheme(utheme);}
}
function modeSwitch(){
    let currentMode=document.documentElement.getAttribute('data-color-mode');
    let newMode = currentMode === "light" ? "dark" : currentMode === "dark" ? "auto" : "light";
    localStorage.setItem("meek_theme", newMode);
    if(themeSettings[newMode]){
        changeTheme(...themeSettings[newMode]);
    }
}
function utterancesTheme(theme){
    const message={type:'set-theme',theme: theme};
    const iframe=document.getElementsByClassName('utterances-frame')[0];
    iframe.contentWindow.postMessage(message,'https://utteranc.es');
}
if(themeSettings[theme]){changeTheme(...themeSettings[theme]);}
console.log("\n %c Gmeek last https://github.com/Meekdai/Gmeek \n","padding:5px 0;background:#02d81d;color:#fff");
</script>

<script>
document.getElementById("pathHome").setAttribute("d",IconList["home"]);
document.getElementById("pathIssue").setAttribute("d",IconList["github"]);



function openComments(){
    cm=document.getElementById("comments");
    cmButton=document.getElementById("cmButton");
    cmButton.innerHTML="loading";
    span=document.createElement("span");
    span.setAttribute("class","AnimatedEllipsis");
    cmButton.appendChild(span);

    script=document.createElement("script");
    script.setAttribute("src","https://utteranc.es/client.js");
    script.setAttribute("repo","QiakaChi/qiakachi.github.io");
    script.setAttribute("issue-term","title");
    
    if(localStorage.getItem("meek_theme")=="dark"){script.setAttribute("theme","dark-blue");}
    else if(localStorage.getItem("meek_theme")=="light") {script.setAttribute("theme","github-light");}
    else{script.setAttribute("theme","preferred-color-scheme");}
    
    script.setAttribute("crossorigin","anonymous");
    script.setAttribute("async","");
    cm.appendChild(script);

    int=self.setInterval("iFrameLoading()",200);
}

function iFrameLoading(){
    var utterances=document.getElementsByClassName('utterances');
    if(utterances.length==1){
        if(utterances[0].style.height!=""){
            utterancesLoad=1;
            int=window.clearInterval(int);
            document.getElementById("cmButton").style.display="none";
            console.log("utterances Load OK");
        }
    }
}

document.addEventListener('DOMContentLoaded', () => {
    const createClipboardHTML = (codeContent, additionalClasses = '') => `
        <pre class="notranslate"><code class="notranslate">${codeContent}</code></pre>
        <div class="clipboard-container position-absolute right-0 top-0 ${additionalClasses}">
            <clipboard-copy class="ClipboardButton btn m-2 p-0" role="button" style="display: inherit;">
                <svg height="16" width="16" class="octicon octicon-copy m-2"><path d="${IconList["copy"]}"></path></svg>
                <svg height="16" width="16" class="octicon octicon-check color-fg-success m-2 d-none"><path d="${IconList["check"]}"></path></svg>
            </clipboard-copy>
            <div class="copy-feedback">Copied!</div>
        </div>
    `;

    const handleCodeElements = (selector = '') => {
        document.querySelectorAll(selector).forEach(codeElement => {
            const codeContent = codeElement.innerHTML;
            const newStructure = document.createElement('div');
            newStructure.className = 'snippet-clipboard-content position-relative overflow-auto';
            newStructure.innerHTML = createClipboardHTML(codeContent);

            const parentElement = codeElement.parentElement;
            if (selector.includes('highlight')) {
                parentElement.insertBefore(newStructure, codeElement.nextSibling);
                parentElement.removeChild(codeElement);
            } else {
                parentElement.parentElement.replaceChild(newStructure, parentElement);
            }
        });
    };

    handleCodeElements('pre.notranslate > code.notranslate');
    handleCodeElements('div.highlight > pre.notranslate');

    let currentFeedback = null;
    document.querySelectorAll('clipboard-copy').forEach(copyButton => {
        copyButton.addEventListener('click', () => {
            const codeContent = copyButton.closest('.snippet-clipboard-content').innerText;
            const tempTextArea = document.createElement('textarea');
            tempTextArea.value = codeContent;
            document.body.appendChild(tempTextArea);
            tempTextArea.select();
            document.execCommand('copy');
            document.body.removeChild(tempTextArea);

            const copyIcon = copyButton.querySelector('.octicon-copy');
            const checkIcon = copyButton.querySelector('.octicon-check');
            const copyFeedback = copyButton.nextElementSibling;

            if (currentFeedback && currentFeedback !== copyFeedback) {currentFeedback.style.display = 'none';}
            currentFeedback = copyFeedback;

            copyIcon.classList.add('d-none');
            checkIcon.classList.remove('d-none');
            copyFeedback.style.display = 'block';
            copyButton.style.borderColor = 'var(--color-success-fg)';

            setTimeout(() => {
                copyIcon.classList.remove('d-none');
                checkIcon.classList.add('d-none');
                copyFeedback.style.display = 'none';
                copyButton.style.borderColor = '';
            }, 2000);
        });
    });
});

</script>


</html>
